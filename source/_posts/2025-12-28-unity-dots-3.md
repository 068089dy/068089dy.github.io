---
title: Unity DOTS学习记录(三)-JobEntity
date: 2025-12-31 11:10:46
tags: 
- unity 
- ECS
- 面向数据
- 高性能
- DOTS
- SIMD
keywords: [unity, ECS, DOTS, 面向数据, SIMD]
---
环境：
Unity：6000.2.10f1
Entities：1.4.3

参考：
https://github.com/Unity-Technologies/EntityComponentSystemSamples

在[上一篇](http://matchding.top/2025/12/28/2025-12-28-unity-dots-2/)中，我们在**RotationSystem**里通过**SystemAPI.Query + foreach**的方式遍历实体，实现旋转逻辑：
```java
foreach (var (transform, speed) in
         SystemAPI.Query<RefRW<LocalTransform>, RefRO<RotationSpeed>>())
{
    transform.ValueRW = transform.ValueRO.RotateY(
        speed.ValueRO.RadiansPerSecond * deltaTime);
}
```
这种方式上手简单，但在实体数量较大时，并不是最优解。原因如下：
* 依然运行在主线程，无法利用多核优势
* 依旧是顺序执行，没有并行


## 使用JobEntity来提高执行效率

```c
[BurstCompile]
protected override void OnUpdate()
{   
    // 并行执行
    var job = new RotateAndScaleJob
    {
        DeltaTime = SystemAPI.Time.DeltaTime, ElapsedTime = (float)SystemAPI.Time.ElapsedTime
    };
    job.Schedule();
}

[BurstCompile]
partial struct RotateAndScaleJob : IJobEntity
{
    public float DeltaTime;
    public float ElapsedTime;
    // 这里Execute方法的参数会自动匹配所有包含LocalTransform和RotationSpeed组件的实体
    void Execute(ref LocalTransform transform, in RotationSpeed speed)
    {
        transform = transform.RotateY(speed.RadiansPerSecond * DeltaTime);
        transform.Scale = math.sin(ElapsedTime);
    }
}
```

* JobEntity默认支持并行调度，不同Chunk之间可以并行操作。
